"""MyProxy Client interface

NERC Data Grid Project

Major re-write of an original class.   This updated version implements methods
with SSL calls with M2Crypto rather use calls to myproxy client executables as
in the original.  This version is adapted and extended from an original 
program myproxy_logon by Tom Uram <turam@mcs.anl.gov>
"""
__author__ = "P J Kershaw"
__date__ = "02/06/05"
__copyright__ = "(C) 2007 STFC & NERC"
__license__ = \
"""This software may be distributed under the terms of the Q Public 
License, version 1.0 or later.

For myproxy_logon see Access Grid Toolkit Public License (AGTPL): 

http://www-unix.mcs.anl.gov/fl/research/accessgrid/about/license.html

This product includes software developed by and/or derived from the Access 
Grid Project (http://www.accessgrid.org) to which the U.S. Government retains 
certain rights."""
__contact__ = "P.J.Kershaw@rl.ac.uk"
__revision__ = '$Id$'

import sys, os
import socket
from M2Crypto import X509, RSA, EVP, m2, BIO, SSL

import base64

# For parsing of properties file
try: # python 2.5
    from xml.etree import cElementTree as ElementTree
except ImportError:
    # if you've installed it yourself it comes this way
    import cElementTree as ElementTree

from ndg.security.common.openssl import OpenSSLConfig, OpenSSLConfigError


class MyProxyClientError(Exception):
    """Catch all exception class"""
    
class GetError(Exception):
    """Exceptions arising from get request to server"""
    
class RetrieveError(Exception):
    """Error recovering a response from MyProxy"""

class _HostCheck(SSL.Checker.Checker):
    """Override SSL.Checker.Checker to allow additional check of MyProxy 
    server identity.  If hostname doesn't match, allow match of host's  
    Distinguished Name against MYPROXY_SERVER_DN setting"""

    def __init__(self, 
                 myProxyServerDN=os.environ.get('MYPROXY_SERVER_DN'),
                 cnHostPfx='host/',
                 **kw):
        """Override parent class __init__ to enable setting of myProxyServerDN
        setting
        
        @type myProxyServerDN: string
        @param myProxyServerDN: Set the expected Distinguished Name of the
        MyProxy server to avoid errors matching hostnames.  This is useful
        where the hostname is not fully qualified
        
        @type cnHostPfx: string
        @param cnHostPfx: globus host certificates are 
        generated by default with a 'host/' prefix to the host name.  Set
        this keyword to '' or None to override and omit the prefix"""
        
        SSL.Checker.Checker.__init__(self, **kw)
        
        self.myProxyServerDN = myProxyServerDN
        self.cnHostPfx = cnHostPfx
        
        
    def __call__(self, peerCert, host=None):
        """Carry out checks on server ID
        @param peerCert: MyProxy server host certificate as M2Crypto.X509.X509
        instance
        @param host: name of host to check
        """
        
        # Globus host certificate has a "host/" prefix - see explanation in
        # __init__.__doc__
        cnHostPfx = isinstance(self.cnHostPfx, basestring) \
                    and self.cnHostPfx or ''
        host = None or cnHostPfx + self.host
        
        try:
            SSL.Checker.Checker.__call__(self, peerCert, host=host)
            
        except SSL.Checker.WrongHost, e:
            # Try match against DN set from MYPROXY_SERVER_DN / config
            # file setting
            peerCertDN = '/' + \
                    peerCert.get_subject().as_text().replace(', ', '/')
            if peerCertDN != self.myProxyServerDN:
                # They match - drop the exception and return all OK instead
                raise e
            
        return True
            
        
class MyProxyClient(object):
    """MyProxy client interface 
    
    Based on protocol definitions in: 
    
    http://grid.ncsa.uiuc.edu/myproxy/protocol/
    
    @type __getCmd: string
    @cvar __getCmd: get command string
    
    @type __infoCmd: string
    @cvar __infoCmd: info command string
    
    @type __destroyCmd: string
    @cvar __destroyCmd: destroy command string
    
    @type __changePassphrase: string
    @cvar __changePassphrase: command string to change cred pass-phrase
    
    @type __storeCmd: string
    @cvar __storeCmd: store command string
    
    @type _hostCertSubDirPath: string
    @cvar _hostCertSubDirPath: sub-directory path host certificate (as tuple)
    
    @type _hostKeySubDirPath: string
    @cvar _hostKeySubDirPath: sub-directory path to host key (as tuple)
    
    @type __validKeys: tuple
    @cvar __validKeys: sets permissable element names for MyProxy XML config
    file
    """
      
    __getCmd="""VERSION=MYPROXYv2
COMMAND=0
USERNAME=%s
PASSPHRASE=%s
LIFETIME=%d"""
 
    __infoCmd="""VERSION=MYPROXYv2
COMMAND=2
USERNAME=%s
PASSPHRASE=PASSPHRASE
LIFETIME=0"""
 
    __destroyCmd="""VERSION=MYPROXYv2
COMMAND=3
USERNAME=%s
PASSPHRASE=PASSPHRASE
LIFETIME=0"""

    __changePassphraseCmd="""VERSION=MYPROXYv2
 COMMAND=4
 USERNAME=%s
 PASSPHRASE=%s
 NEW_PHRASE=%s
 LIFETIME=0"""
   
    __storeCmd="""VERSION=MYPROXYv2
COMMAND=5
USERNAME=%s
PASSPHRASE=
LIFETIME=%d"""

    _hostCertSubDirPath = ('etc', 'hostcert.pem')
    _hostKeySubDirPath = ('etc', 'hostkey.pem')
    
    # valid configuration property keywords
    __validKeys = ('hostname',
                   'port',
                   'serverDN',
                   'serverCNprefix',
                   'gridSecurityDir',
                   'openSSLConfFilePath',
                   'tmpDir',
                   'proxyCertMaxLifetime',
                   'proxyCertLifetime',
                   'caCertFile')

    # Work out default location of proxy file if it exists.  This is set if a
    # call has been made previously to logon / get-delegation
    defProxyFile = sys.platform == 'win32' and 'proxy' or \
    sys.platform in ('linux2', 'darwin') and '/tmp/x509up_u%s'%(os.getuid()) \
    or None

    @classmethod
    def writeProxyFile(cls, proxyCert, proxyPriKey, userCert, filePath=None):
        """Write out proxy cert to file in the same way as myproxy-logon - 
        proxy cert, private key, user cert.  Nb. output from logon can be
        passed direct into this method
        
        @type proxyCert: string 
        @param proxyCert: proxy certificate
        @type proxyPriKey: string
        @param proxyPriKey: private key for proxy
        @type userCert: string
        @param userCert: user certificate which issued the proxy
        @type filePath: string
        @param filePath: set to override the default filePath"""
        
        if filePath is None:
            filePath = MyProxyClient.defProxyFile
            
        if filePath is None:
            MyProxyClientError, \
                "Error setting proxy file path - invalid platform?"
        
        outStr = proxyCert + proxyPriKey + userCert       
        open(MyProxyClient.defProxyFile, 'w').write(outStr)
        try:
            # Make sure permssions are set correctly
            os.chmod(MyProxyClient.defProxyFile, 0600)
        except Exception:
            # Don't leave the file lying around if couldn't change it's
            # permissions
            os.unlink(MyProxyClient.defProxyFile)
            
            raise MyProxyClientError, \
                'Unable to set 0600 permissions for proxy file "%s": %s' % \
                (MyProxyClient.defProxyFile, e)

    @classmethod
    def readProxyFile(cls, filePath=None):
        """Read proxy cert file following the format used by myproxy-logon - 
        proxy, cert, private key, user cert.
        
        @rtype: tuple
        @return: tuple containing proxy cert, private key, user cert"""
        if filePath is None:
            filePath = MyProxyClient.defProxyFile
               
        proxy = open(MyProxyClient.defProxyFile).read()
        
        # Split certs and key into separate tuple items
        return tuple(['-----BEGIN'+i for i in proxy.split('-----BEGIN')[1:]])
        
        
    #_________________________________________________________________________            
    def __init__(self, propFilePath=None, **prop):
        """Make an initial settings for client connections to MyProxy
        
        Settings are held in a dictionary which can be set from **prop,
        a call to setProperties() or by passing settings in an XML file
        given by propFilePath
        
        @param propFilePath:   set properties via a configuration file
        @param **prop:         set properties via keywords - see __validKeys
        class variable for a list of these
        """
        
        # Check for parameter names set from input
        #self.certReqDNparam = None

        # settings dictionary
        self.__prop = {}
        
        # Server host name - take from environment variable if available
        if 'MYPROXY_SERVER' in os.environ:
            self.__prop['hostname'] = os.environ['MYPROXY_SERVER']
            
        # ... and port number
        if 'MYPROXY_SERVER_PORT' in os.environ:
            self.__prop['port'] = int(os.environ['MYPROXY_SERVER_PORT'])
        else:
            # Usual default is ...
            self.__prop['port'] = 7512
            
        self.__prop['proxyCertLifetime'] = 43200
        self.__prop['proxyCertMaxLifetime'] = 43200
       
        # Configuration file used to get default subject when generating a
        # new proxy certificate request
        self.__openSSLConf = OpenSSLConfig()

        
        # Properties set via input keywords
        self.setProperties(**prop)

        # If properties file is set any parameters settings in file will
        # override those set by input keyword
        if propFilePath is not None:
            self.readProperties(propFilePath)


    #_________________________________________________________________________
    def setProperties(self, **prop):
        """Update existing properties from an input dictionary
        Check input keys are valid names"""
        
        invalidKeys = [key for key in prop if key not in self.__validKeys]
        if invalidKeys:
            raise MyProxyClientError, 'Invalid property name(s) set: "%s"' % \
                                    '", "'.join(invalidKeys)
                
        self.__prop.update(prop)

        # Update openssl conf file path
        #
        # Check 'prop' to see if they've been in THIS update
        # Check 'self.__prop' to ensure both are present in
        # order to construct a file path
        if 'openSSLConfFilePath' in prop:            
            self.__openSSLConf.filePath = self.__prop['openSSLConfFilePath']
            self.__openSSLConf.read()
            

    #_________________________________________________________________________
    def readProperties(self, propFilePath=None, propElem=None):
        """Read XML properties from a file or cElementTree node
        
        propFilePath|propertiesElem

        @type propFilePath: string
        @param propFilePath: set to read from the specified file
        
        @type propElem: ElementTree node
        @param propElem: set to read beginning from a cElementTree node
        """

        if propFilePath is not None:
            try:
                tree = ElementTree.parse(propFilePath)
                propElem = tree.getroot()
                
            except IOError, e:
                raise MyProxyClientError, \
                                "Error parsing properties file \"%s\": %s" % \
                                (e.filename, e.strerror)           
            except Exception, e:
                raise MyProxyClientError, \
                                "Error parsing properties file: %s" % str(e)
                                
        if propElem is None:
            raise MyProxyClientError, \
                    "Root element for parsing properties file is not defined"


        # Get properties as a data dictionary
        prop = {}
        try:
            for elem in propElem:
                # Check for string type to avoid exceptions from isdigit and
                # expandvars
                if isinstance(elem.text, basestring):
                    if elem.text.isdigit():
                        prop[elem.tag] = int(elem.text)
                    else:
                        prop[elem.tag] = os.path.expandvars(elem.text)
                else:
                    prop[elem.tag] = elem.text
                    
        except Exception, e:
            raise SessionMgrError, \
                "Error parsing tag \"%s\" in properties file" % elem.tag
        
        self.setProperties(**prop)


    #_________________________________________________________________________
    def __getOpenSSLConfig(self):
        "Get OpenSSLConfig object property method"
        return self.__openSSLConfig
    
    openSSLConfig = property(fget=__getOpenSSLConfig,
                             doc="OpenSSLConfig object")

            
    #_________________________________________________________________________        
    def _initConnection(self, 
                        ownerCertFile=None, 
                        ownerKeyFile=None,
                        ownerPassphrase=None):
        """Initialise connection setting up SSL context and client and
        server side identity checks
        
        @param ownerCertFile: client certificate and owner of credential
        to be acted on.  Can be a proxy cert + proxy's signing cert.  Cert
        and private key are not necessary for getDelegation / logon calls
        @param ownerKeyFile: client private key file
        @param ownerPassphrase: pass-phrase protecting private key if set - 
        not needed in the case of a proxy private key
        """

        # Must be version 3 for MyProxy
        context = SSL.Context(protocol='sslv3')

        if 'caCertFile' in self.__prop:
            context.load_verify_locations(cafile=self.__prop['caCertFile'])
                            
            # Stop if peer's certificate can't be verified
            context.set_allow_unknown_ca(False)
        else:
            context.set_allow_unknown_ca(True)
            
        if ownerCertFile:
            try:
                context.load_cert_chain(ownerCertFile,
                                keyfile=ownerKeyFile,
                                callback=lambda *ar, **kw: ownerPassphrase)
            except Exception, e:
                raise MyProxyClientError, \
            "Error loading CA cert., cert. and key for SSL connection: %s" % e 
            
            # Verify peer's certificate
            context.set_verify(SSL.verify_peer, 1) 
        
           
        # Disable for compatibility with myproxy server (er, globus)
        # globus doesn't handle this case, apparently, and instead
        # chokes in proxy delegation code
        context.set_options(m2.SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS)
        
        # connect to myproxy server
        conn = SSL.Connection(context, sock=socket.socket())
        
        # Check server host identity - if host doesn't match use explicit
        # 'serverDN' 
        # host/<hostname> one
        hostCheck = _HostCheck(host=self.__prop['hostname'],
                               myProxyServerDN=self.__prop.get('serverDN'),
                               cnHostPfx=self.__prop.get('serverCNprefix'))
        conn.set_post_connection_check_callback(hostCheck)
        
        return conn
    
            
    #_________________________________________________________________________        
    def _createCertReq(self, CN, nBitsForKey=1024, messageDigest="md5"):
        """
        Create a certificate request.
        
        @param CN: Common Name for certificate - effectively the same as the
        username for the MyProxy credential
        @param nBitsForKey: number of bits for private key generation - 
        default is 1024
        @param messageDigest: message disgest type - default is MD5
        @return tuple of certificate request PEM text and private key PEM text
        """
        
        # Check all required certifcate request DN parameters are set                
        # Create certificate request
        req = X509.Request()
    
        # Generate keys
        key = RSA.gen_key(nBitsForKey, m2.RSA_F4)
    
        # Create public key object
        pubKey = EVP.PKey()
        pubKey.assign_rsa(key)
        
        # Add the public key to the request
        req.set_version(0)
        req.set_pubkey(pubKey)
        
        defaultReqDN = self.__openSSLConf.reqDN
             
        # Set DN
        x509Name = X509.X509_Name()
        x509Name.CN = CN
        
        if defaultReqDN:
            x509Name.OU = defaultReqDN['OU']
            x509Name.O = defaultReqDN['O']
                        
        req.set_subject_name(x509Name)
        
        req.sign(pubKey, messageDigest)

        return (req.as_der(), key.as_pem(cipher=None))
    
    
    #_________________________________________________________________________           
    def _deserializeResponse(self, msg, *fieldNames):
        """
        Deserialize a MyProxy server response
        
        @param msg: string response message from MyProxy server
        @*fieldNames: the content of additional fields can be returned by 
        specifying the field name or names as additional arguments e.g. info
        method passes 'CRED_START_TIME', 'CRED_END_TIME' and 'CRED_OWNER'
        field names.  The content of fields is returned as an extra element
        in the tuple response.  This element is itself a dictionary indexed
        by field name.
        @return tuple of integer response and errorTxt string (if any)
        """
        
        lines = msg.split('\n')
        
        # get response value
        responselines = filter(lambda x: x.startswith('RESPONSE'), lines)
        responseline = responselines[0]
        respCode = int(responseline.split('=')[1])
        
        # get error text
        errorTxt = ""
        errorlines = filter(lambda x: x.startswith('ERROR'), lines)
        for e in errorlines:
            etext = e.split('=', 1)[1]
            errorTxt += os.linesep + etext
        
        if fieldNames:
            fields = {}
                        
            for fieldName in fieldNames:
                fieldlines = filter(lambda x: x.startswith(fieldName), lines)
                try:
                    # Nb. '1' arg to split ensures owner DN is not split up.
                    field = fieldlines[0].split('=', 1)[1]
                    fields[fieldName]=field.isdigit() and int(field) or field

                except IndexError:
                    # Ignore fields that aren't found
                    pass
                
            return respCode, errorTxt, fields
        else:
            return respCode, errorTxt
    
  
    #_________________________________________________________________________             
    def _deserializeCerts(self, inputDat):
        """Unpack certificates returned from a get delegation call to the
        server
        
        @param inputDat: string containing the proxy cert and private key
        and signing cert all in DER format
        
        @return list containing the equivalent to the input in PEM format"""
        pemCerts = []        
        dat = inputDat
        
        while dat:    
            # find start of cert, get length        
            ind = dat.find('\x30\x82')
            if ind < 0:
                break
                
            len = 256*ord(dat[ind+2]) + ord(dat[ind+3])
    
            # extract der-format cert, and convert to pem
            derCert = dat[ind:ind+len+4]
            
            x509 = X509.load_cert_der_string(derCert)
            pemCert = x509.as_pem()
            
            pemCerts.append(pemCert)
    
            # trim cert from data
            dat = dat[ind + len + 4:]
           
        return pemCerts


    #_________________________________________________________________________   
    def info(self,
             username, 
             ownerCertFile=None,
             ownerKeyFile=None,
             ownerPassphrase=None):
        """return True/False whether credentials exist on the server for a 
        given username
        
        Exceptions:  GetError, RetrieveError
        
        @type username: string
        @param username: username selected for credential
        @type ownerCertFile: string
        @param ownerCertFile: certificate used for client authentication with
        the MyProxy server SSL connection.  This ID will be set as the owner
        of the stored credentials.  Only the owner can later remove 
        credentials with myproxy-destroy or the destroy method.  If not set,
        this argument defaults to $GLOBUS_LOCATION/etc/hostcert.pem 
        @type ownerKeyFile: string 
        @param ownerKeyFile: corresponding private key file.  See explanation
        for ownerCertFile
        @type ownerPassphrase: string
        @param ownerPassphrase: passphrase for ownerKeyFile.  Omit if the
        private key is not password protected.
        """
        globusLoc = os.environ.get('GLOBUS_LOCATION')
        if not ownerCertFile:
            if globusLoc:
                ownerCertFile = os.path.join(globusLoc, 
                                         *MyProxyClient._hostCertSubDirPath)
                ownerKeyFile = os.path.join(globusLoc, 
                                         *MyProxyClient._hostKeySubDirPath)
            else:
                raise MyProxyClientError, \
            "No client authentication cert. and private key file were given"

        # Set-up SSL connection
        conn = self._initConnection(ownerCertFile=ownerCertFile,
                                    ownerKeyFile=ownerKeyFile,
                                    ownerPassphrase=ownerPassphrase)
        
        conn.connect((self.__prop['hostname'], self.__prop['port']))
        
        # send globus compatibility stuff
        conn.write('0')
    
        # send info command - ensure conversion from unicode before writing
        cmd = MyProxyClient.__infoCmd % username
        conn.write(str(cmd))
    
        # process server response
        dat = conn.recv(8192)
         
        # Pass in the names of fields to return in the dictionary 'field' 
        respCode, errorTxt, field = self._deserializeResponse(dat, 
                                                         'CRED_START_TIME', 
                                                         'CRED_END_TIME', 
                                                         'CRED_OWNER')

        return not bool(respCode), errorTxt, field


    #_________________________________________________________________________   
    def changePassphrase(self,
                         username, 
                         passphrase,
                         newPassphrase,
                         ownerCertFile=None,
                         ownerKeyFile=None,
                         ownerPassphrase=None):
        """change pass-phrase protecting the credentials for a given username
        
        Exceptions:  GetError, RetrieveError
        
        @param username: username of credential
        @param passphrase: existing pass-phrase for credential
        @param newPassphrase: new pass-phrase to replace the existing one.
        @param ownerCertFile: certificate used for client authentication with
        the MyProxy server SSL connection.  This ID will be set as the owner
        of the stored credentials.  Only the owner can later remove 
        credentials with myproxy-destroy or the destroy method.  If not set,
        this argument defaults to $GLOBUS_LOCATION/etc/hostcert.pem 
        @param ownerKeyFile: corresponding private key file.  See explanation
        for ownerCertFile
        @param ownerPassphrase: passphrase for ownerKeyFile.  Omit if the
        private key is not password protected.  
        @return none
        """
        globusLoc = os.environ.get('GLOBUS_LOCATION')
        if not ownerCertFile or not ownerKeyFile:
            if globusLoc:
                ownerCertFile = os.path.join(globusLoc, 
                                         *MyProxyClient._hostCertSubDirPath)
                ownerKeyFile = os.path.join(globusLoc, 
                                         *MyProxyClient._hostKeySubDirPath)
            else:
                raise MyProxyClientError, \
            "No client authentication cert. and private key file were given"
        
        # Set-up SSL connection
        conn = self._initConnection(ownerCertFile=ownerCertFile,
                                    ownerKeyFile=ownerKeyFile,
                                    ownerPassphrase=ownerPassphrase)

        conn.connect((self.__prop['hostname'], self.__prop['port']))
        
        # send globus compatibility stuff
        conn.write('0')
    
        # send command - ensure conversion from unicode before writing
        cmd = MyProxyClient.__changePassphraseCmd % (username, 
                                                     passphrase,
                                                     newPassphrase)
        conn.write(str(cmd))
    
        # process server response
        dat = conn.recv(8192)
            
        respCode, errorTxt = self._deserializeResponse(dat)
        if respCode:
            raise GetError, errorTxt


    #_________________________________________________________________________   
    def destroy(self,
                username, 
                ownerCertFile=None,
                ownerKeyFile=None,
                ownerPassphrase=None):
        """destroy credentials from the server for a given username
        
        Exceptions:  GetError, RetrieveError
        
        @param username: username selected for credential
        @param ownerCertFile: certificate used for client authentication with
        the MyProxy server SSL connection.  This ID will be set as the owner
        of the stored credentials.  Only the owner can later remove 
        credentials with myproxy-destroy or the destroy method.  If not set,
        this argument defaults to $GLOBUS_LOCATION/etc/hostcert.pem 
        @param ownerKeyFile: corresponding private key file.  See explanation
        for ownerCertFile
        @param ownerPassphrase: passphrase for ownerKeyFile.  Omit if the
        private key is not password protected.  
        @return none
        """
        globusLoc = os.environ.get('GLOBUS_LOCATION')
        if not ownerCertFile or not ownerKeyFile:
            if globusLoc:
                ownerCertFile = os.path.join(globusLoc, 
                                         *MyProxyClient._hostCertSubDirPath)
                ownerKeyFile = os.path.join(globusLoc, 
                                         *MyProxyClient._hostKeySubDirPath)
            else:
                raise MyProxyClientError, \
            "No client authentication cert. and private key file were given"
        
        # Set-up SSL connection
        conn = self._initConnection(ownerCertFile=ownerCertFile,
                                    ownerKeyFile=ownerKeyFile,
                                    ownerPassphrase=ownerPassphrase)

        conn.connect((self.__prop['hostname'], self.__prop['port']))
        
        # send globus compatibility stuff
        conn.write('0')
    
        # send destroy command - ensure conversion from unicode before writing
        cmd = MyProxyClient.__destroyCmd % username
        conn.write(str(cmd))
    
        # process server response
        dat = conn.recv(8192)
            
        respCode, errorTxt = self._deserializeResponse(dat)
        if respCode:
            raise GetError, errorTxt


    #_________________________________________________________________________   
    def store(self,
              username,
              passphrase, 
              certFile,
              keyFile,
              ownerCertFile=None,
              ownerKeyFile=None,
              ownerPassphrase=None,
              lifetime=None,
              force=True):
        """Upload credentials to the server
        
        @raise GetError:
        @raise RetrieveError:
        
        @type username: string
        @param username: username selected for new credential
        @type passphrase: string
        @param passphrase: pass-phrase for new credential.  This is the pass
        phrase which protects keyfile.
        @type certFile: string
        @param certFile: user's X.509 certificate in PEM format
        @type keyFile: string
        @param keyFile: equivalent private key file in PEM format
        @type ownerCertFile: string
        @param ownerCertFile: certificate used for client authentication with
        the MyProxy server SSL connection.  This ID will be set as the owner
        of the stored credentials.  Only the owner can later remove 
        credentials with myproxy-destroy or the destroy method.  If not set,
        this argument defaults to $GLOBUS_LOCATION/etc/hostcert.pem or if this
        is not set, certFile
        @type ownerKeyFile: string
        @param ownerKeyFile: corresponding private key file.  See explanation
        for ownerCertFile
        @type ownerPassphrase: string 
        @param ownerPassphrase: passphrase for ownerKeyFile.  Omit if the
        private key is not password protected.  Nb. keyFile is expected to
        be passphrase protected as this will be the passphrase used for
        logon / getDelegation.
        @type Force: bool
        @param force: set to True to overwrite any existing creds with the
        same username.  If, force=False a check is made with a call to info.
        If creds already, exist exit without proceeding
        """
        
        lifetime = lifetime or self.__prop['proxyCertMaxLifetime']

        # Inputs must be string type otherwise server will reject the request
        if isinstance(username, unicode):
            username = str(username)
            
        if isinstance(passphrase, unicode):
            passphrase = str(passphrase)
        
        globusLoc = os.environ.get('GLOBUS_LOCATION')
        if not ownerCertFile or not ownerKeyFile:
            if globusLoc:
                ownerCertFile = os.path.join(globusLoc, 
                                         *MyProxyClient._hostCertSubDirPath)
                ownerKeyFile = os.path.join(globusLoc, 
                                         *MyProxyClient._hostKeySubDirPath)
            else:
                # Default so that the owner is the same as the ID of the 
                # credentials to be uploaded.
                ownerCertFile = certFile 
                ownerKeyFile = keyFile
                ownerPassphrase = passphrase
                
        if not force:
            # Check credentials don't already exist
            if self.info(username,
                         ownerCertFile=ownerCertFile,
                         ownerKeyFile=ownerKeyFile,
                         ownerPassphrase=ownerPassphrase)[0]:
                raise MyProxyClientError, \
                        "Credentials already exist for user: %s" % username

        # Set up SSL connection
        conn = self._initConnection(ownerCertFile=ownerCertFile,
                                    ownerKeyFile=ownerKeyFile,
                                    ownerPassphrase=ownerPassphrase)
        
        conn.connect((self.__prop['hostname'], self.__prop['port']))
        
        # send globus compatibility stuff
        conn.write('0')
    
        # send store command - ensure conversion from unicode before writing
        cmd = MyProxyClient.__storeCmd % (username, lifetime)
        conn.write(str(cmd))
    
        # process server response
        dat = conn.recv(8192)
            
        respCode, errorTxt = self._deserializeResponse(dat)
        if respCode:
            raise GetError, errorTxt
        
        # Send certificate and private key
        certTxt = X509.load_cert(certFile).as_pem()
        keyTxt = open(keyFile).read()
        
        conn.send(certTxt + keyTxt)
    
    
        # process server response
        resp = conn.recv(8192)
        respCode, errorTxt = self._deserializeResponse(resp)
        if respCode:
            raise RetrieveError, errorTxt
        
        
    #_________________________________________________________________________           
    def logon(self, username, passphrase, lifetime=None):
        """Retrieve a proxy credential from a MyProxy server
        
        Exceptions:  GetError, RetrieveError
        
        @type username: basestring
        @param username: username of credential
        
        @type passphrase: basestring
        @param passphrase: pass-phrase for private key of credential held on
        server
        
        @type lifetime: int
        @param lifetime: lifetime for generated certificate
        
        @rtype: tuple
        @return credentials as strings in PEM format: the
        user certificate, it's private key and the issuing certificate.  The
        issuing certificate is only set if the user certificate is a proxy
        """
        
        lifetime = lifetime or self.__prop['proxyCertLifetime']

        # Generate certificate request here - any errors will be thrown
        # prior to making the connection and so not upsetting the server
        #
        # - The client will generate a public/private key pair and send a 
        #   NULL-terminated PKCS#10 certificate request to the server.
        certReq, priKey = self._createCertReq(username)

        # Set-up SSL connection
        conn = self._initConnection()
        conn.connect((self.__prop['hostname'], self.__prop['port']))
        
        # send globus compatibility stuff
        conn.write('0')
    
        # send get command - ensure conversion from unicode before writing
        cmd = MyProxyClient.__getCmd % (username, passphrase, lifetime)
        conn.write(str(cmd))
    
        # process server response
        dat = conn.recv(8192)
        respCode, errorTxt = self._deserializeResponse(dat)
        if respCode:
            raise GetError, errorTxt
        
        # Send certificate request
        conn.send(certReq)
    
        # process certificates
        # - 1st byte , number of certs
        dat = conn.recv(1)
        nCerts = ord(dat[0])
        
        # - n certs
        dat = conn.recv(8192)
    
        # process server response
        resp = conn.recv(8192)
        respCode, errorTxt = self._deserializeResponse(resp)
        if respCode:
            raise RetrieveError, errorTxt
    
        # deserialize certs from received cert data
        pemCerts = self._deserializeCerts(dat)
        if len(pemCerts) != nCerts:
            RetrieveError, "%d certs expected, %d received" % \
                                                    (nCerts, len(pemCerts))
    
        # Return certs and private key
        # - proxy cert
        # - private key
        # - rest of cert chain
        creds = [pemCerts[0], priKey]
        creds.extend(pemCerts[1:])
        
        return tuple(creds)
        

    def getDelegation(self, *arg, **kw):
        """Retrieve proxy cert for user - same as logon"""
        return self.logon(*arg, **kw)


#_____________________________________________________________________________   
def main():
    import traceback
    import pdb;pdb.set_trace()
    try:
        CmdLineClient()            
    except Exception, e:
        print "Error: ", e
        print traceback.print_exc()
        sys.exit(1)

#  help="check whether a credential exists")
#
#  help="destroy credential")
#
#  help="change pass-phrase protecting credential")

import optparse
import getpass

class CmdLineClientError(Exception):
    """Errors related to CmdLineClient class"""
    
class CmdLineClient(object):
    """Command line interface to MyProxyClient class.  Where possible it 
    supports the same options as the Globus myproxy-* client commands"""
    
    run = {
        'info': 'runInfo', 
        'logon': 'runLogon',
        'get-delegation': 'runGetDelegation',
        'destroy': 'runDestroy', 
        'change-pass': 'runChangePassphrase',
        'store': 'runStore'
    }

    initOpts = {
        'info': '_addInfoOpts', 
        'logon': '_addLogonOpts',
        'get-delegation': '_addGetDelegationOpts',
        'destroy': '_addDestroyOpts', 
        'change-pass': '_addChangePassphraseOpts',
        'store': '_addStoreOpts'
    }

    cmdUsage = {
        'info': "usage: %prog info arg1 arg2", 
        'logon': "usage: %prog logon arg1 arg2",
        'get-delegation': "usage: %prog get-delegation arg1 arg2",
        'destroy': "usage: %prog destroy arg1 arg2", 
        'change-pass': "usage: %prog change-pass arg1 arg2",
        'store': "usage: %prog store arg1 arg2"
    }
    
    # Keep '%prog' in a separate string otherwise it confuses the % operator
    usage = "usage: %prog" + " [%s] arg1 arg2" % '|'.join(run.keys())    
    version = "%prog 0.8.7"
        
    def __init__(self):
        """Parse the command line and run the appropriate command"""
        
        self.parser = optparse.OptionParser(usage=self.__class__.usage,
                                            version=self.__class__.version)

        # Get command - expected to be 1st arg
        if len(sys.argv) > 1:
            cmd = sys.argv[1]
            if cmd not in self.__class__.run:
                self.parser.error('"%s" command option not recognised' % cmd)
        else:
            self.parser.error('No command option set')

        # Ammend usage string for specific command
        self.parser.set_usage(self.__class__.cmdUsage[cmd])
        
        # Add options based on the command set
        self._addGenericOpts()
        getattr(self, self.initOpts[cmd])()
        
        # Omit command options as parser won't understand it
        (self.opts, args) = self.parser.parse_args(args=sys.argv[2:])     
    
        # Process generic options
        
        # Not all commands require username option - for those that do, check 
        # to see if it was set or omitted
        if hasattr(self.opts, 'username') and not self.opts.username:
            if sys.platform == 'win32':
                self.opts.username = os.environ["USERNAME"]
            else:
                import pwd
                self.opts.username = pwd.getpwuid(os.geteuid())[0]
    
        self.myProxy = MyProxyClient(hostname=self.opts.host,
                                     port=self.opts.port)#,
#                                     O='NDG',
#                                     OU='BADC')

        # Run the command
        getattr(self, self.run[cmd])()

                
    def _addGenericOpts(self):
        """Generic options applying to all commands"""
        self.parser.add_option("-s", 
                          "--pshost", 
                          dest="host",
                          default=os.environ.get('MYPROXY_SERVER'),
                          help="The hostname of the MyProxy server to contact")

        defPort = int(os.environ.get('MYPROXY_SERVER_PORT') or '7512')
        self.parser.add_option("-p", 
                          "--psport", 
                          dest="port", 
                          default=defPort,
                          type="int",
                          help="The port of the MyProxy server to contact")

    def _addInfoOpts(self):
        """Add command line options for info"""
        self.parser.add_option("-l", 
                          "--username", 
                          dest="username", 
                          help="Username for the delegated proxy")

        self.parser.add_option("-C", 
                          "--owner-certfile", 
                          dest="ownerCertFile", 
                          help=\
"""Certificate for owner of credentials to be queried.  If omitted, it 
defaults to $GLOBUS_LOCATION/etc/hostcert.pem.""")
        
        self.parser.add_option("-Y", 
                          "--owner-keyfile", 
                          dest="ownerKeyFile", 
                          default=None,
                          help=\
"""Private key for owner of credentials to be stored.  If omitted, it defaults
to $GLOBUS_LOCATION/etc/hostkey.pem.""")
       
        self.parser.add_option("-w", 
                          "--owner-keyfile-passphrase", 
                          dest="ownerPassphrase", 
                          default=None,
                          help=\
                          "Pass-phrase for Private key used for SSL client")
        
    def _addLogonOpts(self):
        """Add command line options for logon"""
        self.parser.add_option("-l", 
                               "--username", 
                               dest="username", 
                               help="Username for the delegated proxy")

        self.parser.add_option("-t", 
                               "--proxy_lifetime", 
                               dest="lifetime", 
                               default=43200, # = 12 hours in seconds
                               type="int",
                               help=\
            "Lifetime of proxies delegated by the server (default 12 hours)")

        self.parser.add_option("-o", 
                               "--out", 
                               dest="outfile", 
                               help="Location of delegated proxy")

    def _addGetDelegationOpts(self):
        """Add command line options for Get Delegation"""
        self._addLogonOpts()

    def _addDestroyOpts(self):
        """Add command line options for destroy"""
        self.parser.add_option("-l", 
                               "--username", 
                               dest="username", 
                               help=\
                       "Username corresponding to credentials to be removed")

    def _addChangePassphraseOpts(self):
        """Add command line options for change pass-phrase"""
        self.parser.add_option("-l", 
                          "--username", 
                          dest="username", 
                          help="Username for the target proxy")
        
    def _addStoreOpts(self):
        """Add command line options for store"""
        self.parser.add_option("-l", 
                               "--username", 
                               dest="username", 
                               help=\
                       "Username corresponding to credentials to be stored")
        
        self.parser.add_option("-c", 
                          "--certfile", 
                          dest="certFile", 
                          default=None,
                          help="Certificate to be stored")
        
        self.parser.add_option("-y", 
                          "--keyfile", 
                          dest="keyFile", 
                          default=None,
                          help="Private key to be stored")

        self.parser.add_option("-C", 
                          "--owner-certfile", 
                          dest="ownerCertFile", 
                          help=\
"""Cert. for owner of credentials to be stored.  If omitted, it defaults to
$GLOBUS_LOCATION/etc/hostcert.pem.  If this is not readable, the cert. to be
stored is set as the owner.""")
        
        self.parser.add_option("-Y", 
                          "--owner-keyfile", 
                          dest="ownerKeyFile", 
                          default=None,
                          help=\
"""Private key for owner of credentials to be stored.  If omitted, it defaults
to $GLOBUS_LOCATION/etc/hostcert.pem.""")
       
        self.parser.add_option("-w", 
                          "--owner-keyfile-passphrase", 
                          dest="ownerPassphrase", 
                          default=None,
                          help=\
                          "Pass-phrase for Private key used for SSL client")

        self.parser.add_option("-t", 
                               "--proxy_lifetime", 
                               dest="lifetime", 
                               default=43200, # = 12 hours in seconds
                               type="int",
                               help=\
            "Lifetime of proxies delegated by the server (default 12 hours)")

    def runGetDelegation(self):
        """Call MyProxyClient.getDelegation"""
        self.runLogon()
        
    def runLogon(self):
        """Call MyProxyClient.logon"""
        outfile = self.opts.outfile or MyProxyClient.defProxyFile
    
        # Get MyProxy password
        passphrase = getpass.getpass()
            
        # Retrieve proxy cert
        creds = self.myProxy.logon(self.opts.username, 
                                   passphrase, 
                                   lifetime=self.opts.lifetime)
        MyProxyClient.writeProxyFile(*creds)
            
        print "A proxy has been received for user %s in %s." % \
            (self.opts.username, outfile)
            
    def runChangePassphrase(self):
        """Call MyProxyClient.changePassphrase"""
        
        # Get MyProxy password
        passphrase = getpass.getpass(\
                     prompt='Enter (current) MyProxy pass phrase: ')
        
        newPassphrase = getpass.getpass(\
                                 prompt='Enter new MyProxy pass phrase: ')
        
        if newPassphrase != getpass.getpass(\
                     prompt='Verifying - Enter new MyProxy pass phrase: '):
            raise Exception, "Pass-phrases entered don't match"
                
        self.myProxy.changePassphrase(username,
                             passphrase,
                             newPassphrase, 
                             self.opts.certFile,
                             self.opts.keyFile,
                             ownerPassphrase=open('../tmp2').read().strip())            
                
    def runInfo(self):
        """Call MyProxyClient.info"""
        if not self.opts.ownerCertFile or not self.opts.ownerKeyFile:
#            self.opts.ownerCertFile = MyProxyClient.defProxyFile
            # Look for proxy file stored from previous call to logon/
            # get-delegation
            try:
                creds = MyProxyClient.readProxyFile()
            
                # Copy proxy and user certificates
                self.opts.ownerCertFile = './proxy-cert.pem'
                self.opts.ownerKeyFile = './proxy-key.pem'
                open(self.opts.ownerCertFile, 'w').write(creds[0] + ''.join(creds[2:]))
                open(self.opts.ownerKeyFile, 'w').write(creds[1])
            except IOError:
                # No such file - try proceeding regardless
                pass
            
        credExists, errorTxt, fields = self.myProxy.info(self.opts.username, 
                             ownerCertFile=self.opts.ownerCertFile,
                             ownerKeyFile=self.opts.ownerKeyFile,
                             ownerPassphrase=self.opts.ownerPassphrase)
        if errorTxt:
            raise CmdLineClientError, "User %s: %s" % (self.opts.username, 
                                                       errorTxt)
                
        elif credExists:
            print "username: %s" % self.opts.username
            print "owner: %s" % fields['CRED_OWNER']
            print "  time left: %d" % \
                    (fields['CRED_END_TIME'] - fields['CRED_START_TIME'])
        else:
            ownerCert = ''#X509.load_cert(self.opts.ownerCertFile)
            ownerCertDN = ''#'/' + \
                #ownerCert.get_subject().as_text().replace(', ', '/')
            print "no credentials found for user %s, owner \"%s\"" % \
                (self.opts.username, ownerCertDN)
                
    def runDestroy(self):
        """Call MyProxyClient.destroy"""
        self.myProxy.destroy(self.opts.username, 
                            ownerCertFile=self.opts.certFile,
                            ownerKeyFile=self.opts.keyFile,
                            ownerPassphrase=open('../tmp2').read().strip())
        
    def runStore(self):
        self.myProxy.store(self.opts.username, 
                          self.opts.certFile,
                          self.opts.keyFile,
                          ownerCertFile=self.opts.certFile,
                          ownerKeyFile=self.opts.keyFile,
                          ownerPassphrase=open('./tmp').read().strip(),
                          lifetime=self.opts.lifetime)


if __name__ == "__main__":
    main()